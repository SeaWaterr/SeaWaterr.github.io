{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/04/09/hello-world/"},{"title":"软铒精细钓组","text":"当钓况不佳时，或者目标鱼活性低的时候，我们就要考虑精细作钓了。所谓精细钓法就是用小型或者缓慢呈现的拟饵来激发慵懒、活性低的鲈鱼、使其捕食攻击的方法，与旺季路亚鲈鱼的强力钓法相反。今天就来和大家说说路亚常见的精细钓组！ 7个精细钓组 一、倒吊钓组倒吊钓组：一种采用把软饵钩直接系在铅坠上方线上的钓组而发展起来的钓法；软饵挂在钩上之后，整个钓组多少为垂直方向呈现。 操作手法：首先，不要那么频繁地抖动你的竿子。倒吊钓法的魅力在于：它能使你的拟饵表现得更加自然逼真。随着水下的暗流，并结合你自己常用的一些手上的动作，传递给拟饵，会使它呈现出大量不同的表现。 二、内德钓组内德钓组：将浮水软饵挂在一个能站立的蘑菇头形状的铅头钩上，使得钓组在水底呈站立的状态，有助于水底的鱼发现饵。 操作手法：很多钓友都知道，内德钓组很多时候就是在下落的时候，正好被鱼发现，有咬口，所以，慢——是内德钓组的精髓，抛投之后，提竿抖动的动作不要太大，最好让线在松、紧之间做小幅度的抖动；或者不做跳动，仅仅将钓组在水底拖动就好。 三、德州钓组德州钓组：路亚钓法中是使用最广泛的钓组，非常容易组装，德州钓组所需要的组件就是一个曲柄钩、软饵和中通的子弹铜(钨)，配合各种软饵，在陌生水域探底的时候，是不二选择。 操作手法：德州钓组比较讲究节奏，拉动频率不要过快，增加软饵沉水和在水中自由停留的过程，配合小抽动。缺点是滑铅对线有伤害，时常把线前段的1-2米剪掉。 四、卡莱罗纳钓组卡莱罗纳钓组：由子弹铜，响珠，八字环，子线和曲柄钩，外加软虫即可，适合重草区。 操作手法：慢拖，停顿，拉拉停停为主。子线如果半米左右或者更长的话，抛投落水的瞬间一定记得猛拉一米到两米左右，这个动作是为了防止子线缠绕在主线上，然后慢慢拖动，停顿一两秒，再继续拖动，万万不可过度操作鱼饵。 五、咬铅钓组咬铅钓组：由咬铅、钓钩和软饵组成；配重开口铅夹在钓钩上方用来固定钓组，适用细线小饵，想在近岸短距离搜索的话，咬铅钓组就可以上场了。 操作手法：抛出钓组，钓竿水平，假饵沉底后钓竿抬高到垂直位置，然后再放低钓竿，把松弛的线慢慢收紧，如此反复；这一钓组在鲈鱼产卵前期从深水区向浅水区迁徙时和秋季迁回深水时都很有效。 六、无铅钓组无铅钓组：因为无外加的铅锤，所以在软饵选用上以“比重高”、“尾部尾巴偏大”或“特别会摆动尾巴”为上选，因为没有多于钓组配件，所以游起来特别的逼真。适用于砂砾底部水域。 操作手法：无铅钓组主要是钓飘落的行程，抛饵入水后，首先要放点多余的虚线，还要等待。在等待的同时还要再放点多余的虚线，等待着拟饵的落底。放虚线是为了让拟饵尽量地更加自然的下沉落入你设定好的标点。 七、维基钓组维基钓组：又称wacky钓组，这个驰骋在各大竞技赛场多年的经典钓组中，Wacky专用的wacky钩也为各路钓手立下了汗马功劳。Wacky钩的特点就是钩柄延伸出来的挡针，能够有效地防止挂草。 操作手法：透过竿先微微的抖动，让软虫在水里呈现自然的蠕动泳形，也可在软虫左右两侧塞入铅针，改变其蠕动的泳形，此种钓组对大嘴黑鲈有十分致命的吸引力。","link":"/2021/04/16/2021-4-16/"},{"title":"瓜子亮片","text":"瓜子仁亮片钓组在水中高速旋转，闪闪发光，像极了落水挣扎的昆虫，对小型鱼类如白条、马口、奶翘、奶鲈诱惑力十足，堪称绝杀，但是这个钓组组装起来相比较其他路亚钓组来说有点复杂，下面介绍一下瓜子仁亮片钓组的组装方法和使用技巧。 瓜子仁亮片钓组的组成部分：助投器、子线、瓜子仁亮片、太空豆、鱼钩。 钓组的组装步骤第一步 助投器先将主线线头通过助投器尖的一端穿入，穿过来以后在主线线头上面绑一个双圈，如下图： 第二步 绑钩子取一段60cm左右的子线，1号一下的尼龙线就可以，在尼龙线的一端绑上鱼钩（可以选择金柚钩），这一步没搞过手竿的人比较麻烦，钩子小的话更不好绑，需要多练习，绑钩的步骤看下图： 第三步 上太空豆将子线的另一端穿入太空豆前面的线圈，穿过去几厘米就行了，然后把太空豆撸到子线上，然后把太空豆撸到离鱼钩半厘米的地方,在太空豆上方穿入档珠,然后再把瓜子仁亮片凹处向下也穿到子线上，如下图。 第三步 组合助投器把子线绑在第一步的那个双圈上，钓组就基本完成了，如下图：","link":"/2021/04/16/%E7%93%9C%E5%AD%90%E4%BA%AE%E7%89%87/"},{"title":"路亚线结","text":"在使用路亚饵作钓的过程中，线结是比较基础的一项技能，正确的使用和绑制一种线结关系到你作钓的成功与否。对于连接路亚饵的线结，目前有很多种绑制方式，但是不是所有的方式都是靠谱或有效的，因为大家都知道，线的拉力磅数一般指的是直线拉力值，但是在线打结后的拉力值会降低不少，如果没有一个有效的线结的话，你打结后的线的拉力值可能会降到原来的50%甚至更低，那样势必会影响整个线组的强度。 现在就介绍几种比较简单，且对钓线本身拉力值损失较小的常见线结供各位参考，这些线结特别适用于尼龙线或氟碳线。 IMPROVED CLINCH KNOT（加强型结）： 这个线结比较常见，绑起来也比较简单，适合绑的东西比较多，比如连接钓钩、路亚、JIG等等都是可以的。首先将线穿过线孔（可以穿一次也可以穿两次），然后将传过来的一端的线绕着主线主线，绕上5圈（缠绕圈数可以根据需求，一般5圈足够），最后在穿过绕线预留的空间，慢慢拉紧即可。这个线结经过测试，可以保留大约95%的强度，并且比较方便绑制各类路亚和配件。 PALOMAR KNOT（帕洛结）： 此线结也是比较简单的线结，但是强度却非常可靠，它可以保留钓线95%以上的强度，比较适合链接别针、中小型路亚以及钓钩等等，但是要是用此线结绑比较大的路亚，可能需要预留的线要比较长，绑起来可能略有不便，绑这个线结的方法也很简单，看图即可了解。 NON-SLIP LOOP KNOT（防滑环结）： 这个线结的特点是赋予连接的路亚或鱼钩较大的自由性，因为这个线结并不是完全锁死固定在连接环上的，而是有空间，这样可以让一些税种姿态较大路亚的水中拥有更多的自由摆动空间，具体方法是先将主线上打一个简单的小结但不要拉紧，然后将下端预留出来的线穿过线孔，然后再顺势穿过刚才在主线上打的那个小结的孔，随后将穿过小结孔的线绕在主线上5圈左右，最后再穿过主线上打结的小孔，拉紧即可。 BLOOD KNOT（布拉德结）： 这个线结是可以将两段不同磅数的钓线链接，它可以用于连接前导线，比较适合连接两根差距不是很大的钓线，比如15磅和20磅左右这样的情况，不太适合用于连接50磅的钓线。它的绑法也很简单，直接看图就好了。 SURGEON’S KONT（医生结）： 这个线结与上一个线结的用途一样，绑法也比较简单，打结也比较快速，具体绑法如图。不过要注意绑这个结，有一端的线要比另一端的线要短一些才可以，这样才能方便在小结里缠绕。 简单的与线杯连接方法： 这是主线与线杯连接打结的，也是很简单的一种方式，无论双轴卷线器还是纺车轮都可以使用，具体方法可以看图所示 另外再附上多种线结：","link":"/2021/04/16/%E8%B7%AF%E4%BA%9A%E7%BA%BF%E7%BB%93/"},{"title":"路亚翘嘴","text":"了解路亚对象🐟翘嘴 翘嘴习性首先是了解翘嘴的习性。所谓知己知彼，才能够百战不殆。既然是路亚翘嘴，那么就必须先了解翘嘴的习性。不过需要清楚的是，在不同环境下养大的翘嘴，其生活习性也会有不同，故此，除了了解翘嘴的习性，还需要弄清楚所在地区的环境。据了解，翘嘴生长十分快速的一大原因是翘嘴没有休眠期，一年四季都在进食，并且水面越大，大型翘嘴甚至巨翘也就越容易出现。翘嘴的活动范围很大，白天是时候想要钓翘嘴的话，采用船钓会比较轻松一些，不过，这也需要路亚者提前找对钓点。除了下雨天的时候，翘嘴会全天候进食之外，其他情况下，翘嘴一般在早晨和傍晚的时候进食。另外，翘嘴喜欢集体围捕猎物，因为，只要路亚者找对了钓点，一般情况下都能够大丰收。 翘嘴饵鱼路亚翘嘴的时候，饵鱼十分重要，这里的饵鱼一般指的是白条、泥鳅、小虾以及黄鳝等，据了解，这些饵鱼当中，翘嘴最喜欢的是泥鳅。据悉，翘嘴的游动速度和翘嘴的体重有十分直接的关系，一般情况下，在2千克以下的翘嘴，其游动速度明显比2.5千克以上的翘嘴游动的快，不过，大型的翘嘴虽然活动不是那么灵活，但是十分谨慎，因此，路亚翘嘴没有那么简单，并且白天路亚翘嘴明显难于晚上路亚翘嘴。 翘嘴标点其次是寻找翘嘴的标点。翘嘴的标点一般有两种情况，分别是饵鱼聚集的地方和翘嘴藏身的地方。 饵鱼聚集先来说第一种，由于翘嘴主要攻击的猎物是小鱼小虾，而这些小鱼小虾一般生活的地方都是在浅水区。浅滩区生活着许许多多的浮游生物，并且经常会吸引一些昆虫，这些浮游生物和昆虫等会吸引饵鱼的聚集，尤其是浅滩的面积足够宽大的地方，许多饵鱼能够从掠食鱼类的嘴边逃脱，因此，在浅滩区有着一个小型的食物链。故而，当饵鱼成群结队的在浅滩穿梭的时候，翘嘴就会在浅滩附近潜伏，等到抓捕的最佳时机，伺机而动。因此，路亚者在路亚翘嘴之前可以通过寻找弧形水面的过湾处、回水湾、注水口、进水口以及水草边、渔民区、码头等饵鱼经常出没的地方找到标点。 翘嘴藏身第二种是翘嘴喜欢在大水面的地方四处游动，翘嘴十分机灵，除了不会在没有饵鱼的地方藏身之外，翘嘴藏身的地方通常不会太久，换而言之就是翘嘴经常换藏身之处。通常翘嘴会藏身的地方有大面积的回水湾、水库或者河流、湖泊的深水区、暗岛、养殖网箱的下方、水流的急缓流交接处、桥墩处、深水区和浅水区的交界处等。由于翘嘴的藏身之处很难确定，因此，路亚者寻找标点的时候一般选择寻找饵鱼聚集的地方。 判断鱼情一看再次是判断翘嘴的鱼情。一看，即路亚者要先观察标点附近的水面情况，如果从远处观察，发现水面不平静的话，有可能不平静的水下面是饵鱼戏水、翘嘴攻击饵鱼等，并且可以听到一些声音，如果听到的炸水声音越大，说明攻击饵鱼的翘嘴体型也越大。如果从近处观察，一般在靠近岸边的水草和乱石堆下面如果发现有小鱼小虾和泥鳅、黄鳝等之外，那么水草和乱石堆附近的浅水区和深水区交接处一定藏有翘嘴。 二问二问，二问指的是路亚者可以向周围的钓友们询问打听鱼情，在和钓鱼聊天的同时，可以观察一下钓友的鱼护内有些什么鱼，根据观察到的和打探到的消息进一步判断水情和鱼情。 三探三探，所谓探，就是要路亚者将拟饵抛到水中去试探鱼情，试探水中的鱼情的时候，既可以用7到10克的亮片多抛几次，也可以通过15克的亮片进行远抛试探。试抛之后，路亚者需要用心感受握鱼竿的手感，看看20分钟的时间内水下是否有动静，从而判断出水下面有没有藏身的翘嘴。 出钓时间最后是出钓的时间，前面笔者已经说过，翘嘴一年四季都会进食，没有单独的休眠期，其中1到3月份和10到12月份的鱼情基本上保持一致，这段时间内，气温比较低，低温情况下，饵鱼都藏在深水区，故而翘嘴也多在深水区活动，很少靠近浅水区甚至岸边。如果这段时间内要钓翘嘴的话，可以利用天气变化比较大的时间段。4到6月份是路亚翘嘴的最好时机，其中4月份到5月初这一段时间内，下午16点之后是比较理想的路亚翘嘴的时间；从5月下旬到6月初的时候，路亚翘嘴的最佳时间是下午18点之后；而进入6月份以后，翘嘴一般等到天黑之后才会进食，此时最佳的路亚翘嘴的时间是晚上的19点到21点这个时间段。7月份到9月份的时候，由于阳光比较强烈，此时，白天的时候翘嘴多藏身在深水区或者桥墩、大坝等有阴凉的地方。一旦到了晚上，水面一旦炸水，基本上都可以确定附近有翘嘴。因此，7到9月份的时候，路亚翘嘴的最佳时间也都在晚上，不过路亚者需要注意这个时间段，天气的变化会对翘嘴产生一定的影响。 转载 关于路亚—翘嘴篇","link":"/2021/04/19/%E8%B7%AF%E4%BA%9A%E7%BF%98%E5%98%B4/"},{"title":"css 布局的几种方式","text":"CSS 的布局应该是 CSS 体系中的重中之重了，主要的布局方式有 table 表格布局（早期），float 浮动布局和 flex 布局，还有针对于移动端的响应式布局，不论是工作还是面试都是非常重要的知识。 1 table 布局table 布局是最简单的布局方式了，下面我们来看一个简单的例子 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS 布局&lt;/title&gt;&lt;/head&gt;&lt;style&gt;.container{ height:200px; width: 200px;}.left{ background-color: red}.right{ background-color: green}&lt;/style&gt;&lt;body&gt; &lt;table class=container&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=left&gt; 左 &lt;/td&gt; &lt;td class=right&gt; 右 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 table 的特性决定了它非常适合用来做布局，并且表格中的内容可以自动居中，这是之前用的特别多的一种布局方式 而且也加入了 display：table;dispaly:table-cell 来支持 teble 布局。用法如下 12345678910111213141516&lt;style&gt;.table{ display: table}.left{ display: table-cell;}.right{ display: table-cell}&lt;/style&gt;&lt;div class=table&gt; &lt;div class=left&gt;&lt;/div&gt; &lt;div class=right&gt;&lt;/div&gt;&lt;/div&gt; 但是它也有自身的局限性，比如 table 比其它 html 标记占更多的字节（造成下载时间延迟,占用服务器更多流量资源），table 会阻挡浏览器渲染引擎的渲染顺序。(会延迟页面的生成速度,让用户等待更久的时间)，但是某些情况下，当采用其他方式不能很好的达到自己的效果时，采用 table 布局能适应当前场景。 2 flex 布局2.1 盒模型在介绍 flex 布局之前，我们先了解一下盒模型的概念，这个是 css 最基础的概念，首先，我们引用一张图来解释 这是百度百科里面盒模型的一张图。首先最中间的是 content 区域，即我们常说的内容区。我们通常设置的 height 和 width 就是设置的这部分的长度。内容区外部是 padding 区域，这部分指的是内容区到边框的区域，即我们常说的内边距。然后就是 border 区，border 区本身也是占据空间的。边框外面是 margin 区，这部分指的是当前元素与其他元素的距离，即常说的外边距。 首先要明白我们平常说的宽度和高度指的是内容区的宽度和高度。 然后计算一个盒子占用的空间是 content + padding + border + margin 2.2 display / poistion这里还要介绍两个属性，display 和 poistion display 有如下几个值 block（此元素将显示为块级元素，此元素前后会带有换行符。） inline（默认。此元素会被显示为内联元素，元素前后没有换行符。） inline-block （对外表现为行内块元素，对内表现为块级元素） position 有如下几个值 static（默认情况，存在文档流当中） relative（根据元素本身原来所应该处的位置偏移，不会改变布局的计算） absolute（绝对定位，脱离文档流，不会对别的元素造成影响，相对的是父级最近的 relative 或者 absolute 定位元素） fixed（绝对定位，脱离文档流，相对于的是屏幕，就是那些浮动的广告那样，怎么拉都固定在同一个位置，而 absolute 元素离开屏幕就看不见了） position 的层叠是按顺序层叠的，不过可以通过设置 z-index 来改变层叠顺序，只有 relative，absolute，fixed 可以设置 z-index。 2.3 flexbox 布局flexbox 布局即弹性盒子布局，它的特点是盒子本来就是并列的，只需要指定宽度，来看一个经典的三栏布局的例子 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS 布局&lt;/title&gt;&lt;/head&gt;&lt;style&gt;.container{ height:200px; width: 200px; display: flex}.left{ background-color: red; flex: 1;}.middle{ background-color: yellow; flex: 1; }.right{ background-color: green; flex: 1;}&lt;/style&gt;&lt;body&gt; &lt;div class=container&gt; &lt;div class=left&gt;&lt;/div&gt; &lt;div class=middle&gt;&lt;/div&gt; &lt;div class=right&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 有时我们可能需要两边定宽，中间自适应，那么可以这样写 123456789101112.left{ background-color: red; width: 20px;}.middle{ background-color: yellow; flex: 1; }.right{ background-color: green; width: 20px;} 效果如下 3 float 布局float 布局应该是目前各大网站用的最多的一种布局方式了，但是也特别复杂，这里详细讲一下 首先，什么是浮动？ 浮动元素是脱离文档流的，但不脱离文本流，这是什么意思呢，用过 word 的应该知道有一种图片环绕的方式是文字环绕吧，就是这种效果。 那么它有什么特点呢 对自身的影响 float 元素可以形成块，如 span 元素。可以让行内元素也拥有宽和高，因为块级元素具有宽高 浮动元素的位置尽量靠上 尽量靠左（float:left）或右（float:right），如果那一行满足不了浮动元素的宽度要求，则元素会往下掉 对兄弟元素的影响 不影响其他块级元素的位置 影响其他块级元素的文本 上面贴非 float 元素 旁边贴 float 元素或者边框 对父级元素的影响 从布局上 “消失” 高度塌陷 3.1 高度塌陷什么是高度塌陷，举个例子吧 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS 布局&lt;/title&gt;&lt;/head&gt;&lt;style&gt;*{ margin: 0; padding: 0;}.container{ width: 200px; background-color:red;}.left{ background-color: yellow; float: left; height: 50px; width:50px;}.right{ background-color: yellow; float: right; height: 50px; width:50px;}&lt;/style&gt;&lt;body&gt; &lt;div class=container&gt; &lt;span class=left&gt;float&lt;/span&gt; &lt;span&gt;我是字&lt;/span&gt; &lt;span class=right&gt;float&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;container&quot; style=&quot;height: 200px;background: blue&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 从图中可以看出，两个 float 元素虽然包含在第一个 container 中，但是却超出了第一个 container 的范围，在文档流中，父元素的高度默认是被子元素撑开的，也就是子元素多高，父元素就多高。 但是当为子元素设置浮动以后，子元素会完全脱离文档流，此时将会导致子元素无法撑起父元素的高度，导致父元素的高度塌陷。 解决办法有下面几种 父元素设置 overflow: auto 或者 overflow: hidden 效果如下 - 给父元素加一个 after 伪类 1234567.container::after{ content:''; clear:both; display:block; visibility:hidden; height:0; } 效果如下 这也是目前各大网站比较主流的清除浮动的方式，还有一些其他方式这里就不详细讲了，毕竟这是一篇讲布局的文章。 3.2 两栏布局首先我们要明白为什么可以用 float 实现布局。其实上面的例子我们大概就可以看出来了，黄红黄这不就是一个标准的三栏布局吗。其实并没有，我们看看下面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS 布局&lt;/title&gt;&lt;/head&gt;&lt;style&gt;*{ margin: 0; padding: 0;}.container{ width: 400px; height: 200px;}.left{ background-color: yellow; float: left; height: 100%; width:100px;}.right{ background-color: red; margin-left: 100px; height:100%;}.container::after{ content: ''; display: block; visibility: hidden; clear: both}&lt;/style&gt;&lt;body&gt; &lt;div class=container&gt; &lt;div class=left&gt;&lt;/div&gt; &lt;div class=right&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下 上面代码中最重要的是 `margin-left: 100px;`，这一句将浮动元素的位置空了出来，所以右边栏里面的元素不会影响到浮动的 div。 这就是浮动布局的基本思想。 3.3 三栏布局讲完两栏布局再讲一下三栏布局，思路主要是左边一个浮动元素，右边一个浮动元素。这里有个小问题，中间的元素要写在最后，因为中间元素假设有块级元素的话，会影响右边浮动元素的定位，这里演示一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS 布局&lt;/title&gt;&lt;/head&gt;&lt;style&gt;*{ margin: 0; padding: 0;}.container{ width: 400px; height: 200px;}.left{ background-color: yellow; float: left; height: 100%; width:100px;}.right{ background-color: green; float: right; height: 100%; width:100px;}.middle{ background-color: red; margin-left: 100px; margin-right: 100px; height:100%;}.container::after{ content: ''; display: block; visibility: hidden; clear: both}&lt;/style&gt;&lt;body&gt; &lt;div class=container&gt; &lt;div class=left&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt; &lt;div class=right&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 因为浮动元素会把块级元素的位置空出来，所以这里右边的浮动元素把上面的位置空了下来，所以正确的写法应该是 12345&lt;div class=container&gt; &lt;div class=left&gt;&lt;/div&gt; &lt;div class=right&gt;&lt;/div&gt; &lt;div class=&quot;middle&quot;&gt;&lt;/div&gt;&lt;/div&gt; 效果如下 这样我们就实现了最基本的三栏布局 4 响应式布局4.1 meta 标签最简单的处理方式是加上一个 meta 标签 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; 4.2 使用 remrem 指的是 html 元素的 font-size，html 元素的 font-size 默认是 16px，所以 1 rem = 16px；然后根据 rem 来计算各个元素的宽高，然后配合 media query 就可以实现自适应。 4.3 media querycss2 允许用户根据特定的 media 类型定制样式，基本语法如下 123@media screen and (max-width: 360px) { html { font-size: 12px; }} 意思就是： 当屏幕的宽度小于等于 360 px 的时候 html 的字体大小为 12 px。 有一个需要注意的点是范围大的要放在上面，范围小的放在下面。假设有两个样式，一个适应 360px 以下，一个适应 640px 以下，如果 360px 的放在上面，但是小于 360px 同样满足小于 640px，这就不是我们想要的结果了，所以范围大的需要放在上面。 5 总结这里只是简单的介绍了一下 css 的各种布局，如果想深入了解的话建议多看看相关的文章，比如浮动布局还包括圣杯布局，双飞翼布局等，本文只是 css 布局的基本入门，并不能真正满足一些需求，所以如果想深入了解的话还是需要多看看相关的文章. 转自css 布局的几种方式","link":"/2021/04/25/css-%E5%B8%83%E5%B1%80%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"title":"CSS Grid 网格布局","text":"它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。 上图这样的布局，就是 Grid 布局的拿手好戏。 Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 一基本概念学习 Grid 布局之前，需要了解一些基本概念。 1.1 容器和项目采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item） 12345&lt;div&gt; &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。 注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid 布局只对项目生效。 1.2 行和列容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。 上图中，水平的深色区域就是\"行\"，垂直的深色区域就是\"列\"。 1.3 单元格行和列的交叉区域，称为”单元格”（cell）。 正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。 1.4 网格线划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。 上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。 二、容器属性Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。 2.1 display 属性display: grid指定一个容器采用网格布局。 123div { display: grid;} 上图是display: grid的效果。默认情况下，容器元素都是块级元素，但也可以设成行内元素。 123div { display: inline-grid;} 上面代码指定div是一个行内元素，该元素内部采用网格布局。 上图是display: inline-grid的效果。注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 2.2 grid-template-columns 属性，grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 12345.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;} 上面代码指定了一个三行三列的网格，列宽和行高都是100px。 除了使用绝对单位，也可以使用百分比。 12345.container { display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%;} (1)repeat()有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。 12345.container { display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%);} repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。 repeat()重复某种模式也是可以的。 1grid-template-columns: repeat(2, 100px 20px 80px); 上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。 (2)auto-fill 关键字有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container { display: grid; grid-template-columns: repeat(auto-fill, 100px);} 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。 (3)fr 关键字为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。 1234.container { display: grid; grid-template-columns: 1fr 1fr;} 上面代码表示两个相同宽度的列。 fr可以与绝对长度的单位结合使用，这时会非常方便。 1234.container { display: grid; grid-template-columns: 150px 1fr 2fr;} 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 (4)minmax()minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 (5)auto 关键字auto关键字表示由浏览器自己决定长度。 1grid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 (6)网格线的名称grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。 12345.container { display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];} 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 (7)布局实例grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。 1234.wrapper { display: grid; grid-template-columns: 70% 30%;} 上面代码将左边栏设为70%，右边栏设为30%。 传统的十二网格布局，写起来也很容易。 1grid-template-columns: repeat(12, 1fr); 2.3grid-row-gap 属性，grid-column-gap 属性，grid-gap 属性grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。 1234.container { grid-row-gap: 20px; grid-column-gap: 20px;} 上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。 1grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; 因此，上面一段 CSS 代码等同于下面的代码。 123.container { grid-gap: 20px 20px;} 如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 2.4 grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 12345678.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i';} 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 123grid-template-areas: 'a a a' 'b b b' 'c c c'; 上面代码将9个单元格分成a、b、c三个区域。 下面是一个布局实例。 123grid-template-areas: &quot;header header header&quot; &quot;main main sidebar&quot; &quot;footer footer footer&quot;; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 123grid-template-areas: 'a . c' 'd . f' 'g . i'; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 2.5 grid-auto-flow 属性划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。 1grid-auto-flow: column; 上面代码设置了column以后，放置顺序就变成了下图。 grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。 下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局。 上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。 现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。 1grid-auto-flow: row dense; 上面代码的效果如下。 上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。 如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。 1grid-auto-flow: column dense; 上面代码的效果如下。 上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。 2.6justify-items 属性，align-items 属性，place-items 属性justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。 1234.container { justify-items: start | end | center | stretch; align-items: start | end | center | stretch;} 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 123.container { justify-items: start;} 上面代码表示，单元格的内容左对齐，效果如下图。 123.container { align-items: start;} 上面代码表示，单元格的内容头部对齐，效果如下图。 place-items属性是align-items属性和justify-items属性的合并简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 下面是一个例子。 1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 2.7justify-content 属性，align-content 属性，place-content 属性justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 1234.container { justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; } 这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。） start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 下面是一个例子。 1place-content: space-around space-evenly; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 2.8grid-auto-columns 属性，grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。 123456.container { display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px; } 上面代码指定新增的行高统一为50px（原始的行高为100px）。 2.9grid-template 属性，grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。 三、项目属性下面这些属性定义在项目上面。 3.1grid-column-start 属性，grid-column-end 属性，grid-row-start 属性，grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 { grid-column-start: 2; grid-column-end: 4;} 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。 上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。 除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。 下面的例子是指定四个边框位置的效果。 123456.item-1 { grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;} 这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。 1234.item-1 { grid-column-start: header-start; grid-column-end: header-end;} 上面代码中，左边框和右边框的位置，都指定为网格线的名字。 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 { grid-column-start: span 2;} 上面代码表示，1号项目的左边框距离右边框跨越2个网格。 这与下面的代码效果完全一样。 123.item-1 { grid-column-end: span 2;} 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 3.2grid-column 属性，grid-row 属性grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 1234.item { grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;} 下面是一个例子。 1234567891011.item-1 { grid-column: 1 / 3; grid-row: 1 / 2;}/* 等同于 */.item-1 { grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;} 上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 1234567891011.item-1 { background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;}/* 等同于 */.item-1 { background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;} 上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。 斜杠以及后面的部分可以省略，默认跨越一个网格。 1234.item-1 { grid-column: 1; grid-row: 1;} 上面代码中，项目item-1占据左上角第一个网格。 3.3 grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 { grid-area: e;} 上面代码中，1号项目位于e区域，效果如下图。 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item { grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;} 下面是一个例子。 123.item-1 { grid-area: 1 / 1 / 3 / 3;} 3.4justify-self 属性，align-self 属性，place-self 属性justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 1234.item { justify-self: start | end | center | stretch; align-self: start | end | center | stretch;} 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 下面是justify-self: start的例子。 123.item-1 { justify-self: start;} place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。 1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。","link":"/2021/04/26/CSS-Grid-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/"}],"tags":[{"name":"钓组","slug":"钓组","link":"/tags/%E9%92%93%E7%BB%84/"},{"name":"对象🐟","slug":"对象🐟","link":"/tags/%E5%AF%B9%E8%B1%A1%F0%9F%90%9F/"},{"name":"布局","slug":"布局","link":"/tags/%E5%B8%83%E5%B1%80/"}],"categories":[{"name":"路亚","slug":"路亚","link":"/categories/%E8%B7%AF%E4%BA%9A/"},{"name":"钓组","slug":"路亚/钓组","link":"/categories/%E8%B7%AF%E4%BA%9A/%E9%92%93%E7%BB%84/"},{"name":"技巧","slug":"路亚/技巧","link":"/categories/%E8%B7%AF%E4%BA%9A/%E6%8A%80%E5%B7%A7/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"样式","slug":"前端/样式","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%A0%B7%E5%BC%8F/"}]}